#!/usr/bin/env python

import contextlib
import glob
import optparse
import os
import re
import shutil
import signal
import sys
from collections import defaultdict


bitbake_paths = ['poky/bitbake', 'bitbake']
layer_patterns = [
    '*/*/',
    '*/',
    '{oedir}/*/',
    '{oedir}/*/*/',
]


class Terminate(BaseException):
    pass


def sigterm_exception(signum, stackframe):
    raise Terminate()


@contextlib.contextmanager
def status(message, outfile=sys.stdout):
    """Show the user what we're doing, and whether we succeed"""
    outfile.write('{0}..'.format(message))
    outfile.flush()
    try:
        yield
    except KeyboardInterrupt:
        outfile.write('.interrupted\n')
        raise
    except Terminate:
        outfile.write('.terminated\n')
        raise
    except BaseException:
        outfile.write('.failed\n')
        raise
    outfile.write('.done\n')


def process_arguments(cmdline_args):
    parser = optparse.OptionParser(description='Setup a build directory for bitbake')
    parser.add_option('-m', '--machine',
        help='(re)configure the config files for the specified machine')
    parser.add_option('-o', '--oedir', default='{scriptsdir}/../..',
        help='the toplevel directory which holds your layers (default: %(default)s)')
    parser.add_option('-t', '--templatedir', default='{scriptsdir}/../conf',
        help='directory containing the template {bblayers,local}.conf.in (default: %(default)s)')

    parser.add_option('-f', '--force', action='store_true', default=False,
        help='force overwrite of existing configuration files')

    opts, args = parser.parse_args(cmdline_args)
    opts.oedir = opts.oedir.format(scriptsdir=os.path.dirname(__file__))
    opts.oedir = os.path.abspath(opts.oedir)
    opts.templatedir = opts.templatedir.format(scriptsdir=os.path.dirname(__file__))
    opts.templatedir = os.path.abspath(opts.templatedir)

    if len(args) < 1:
        parser.print_help()
        sys.exit(2)

    opts.builddir = args[0]
    if not os.path.isabs(opts.builddir):
        if os.getcwd().endswith(os.path.normpath(opts.builddir)):
            print("Already in build directory '%s', assuming build dir is '%s'" %
                  (opts.builddir, os.getcwd()))
            opts.builddir = os.getcwd()
        else:
            opts.builddir = os.path.abspath(opts.builddir)

    for path in bitbake_paths:
        bitbake_path = os.path.join(opts.oedir, path)
        if os.path.exists(bitbake_path):
            break
    else:
        sys.exit("Unable to locate bitbake relative to %s" % opts.oedir)

    opts.bitbakedir = bitbake_path

    sys.path[0:0] = [os.path.join(bitbake_path, 'lib')]

    try:
        import bb
    except ImportError as exc:
        sys.exit("Unable to import 'bb' python package: %s" % exc)

    return opts


class Layer(object):
    def __init__(self, path, confpath, name, priority, pattern, depends):
        self.path = path
        self.confpath = confpath
        self.name = name
        self.priority = priority
        self.depends = depends
        self.pattern = pattern

    def __repr__(self):
        return 'Layer(%s, %s, %s, %s, %s, %s)' % (repr(self.path), repr(self.confpath), repr(self.name), repr(self.priority), repr(self.pattern), repr(self.depends))

    def __hash__(self):
        return hash(repr(self))

    @staticmethod
    def from_layerpath(layer_path, data=None):
        layers = []

        if data is None:
            data = bb.data.init()
            bb.parse.init_parser(data)

        lconf = os.path.join(layer_path, 'conf', 'layer.conf')
        ldata = data.createCopy()
        ldata.setVar('LAYERDIR', layer_path)
        ldata = bb.parse.handle(lconf, ldata, include=True)
        ldata.expandVarref('LAYERDIR')

        collections = (ldata.getVar('BBFILE_COLLECTIONS', True) or '').split()
        if not collections:
            name = os.path.basename(layer_path)
            l = Layer(layer_path, lconf, name, 0, None, set())
            layers.append(l)

        for name in collections:
            pattern = ldata.getVar('BBFILE_PATTERN_%s' % name, True)
            priority = ldata.getVar('BBFILE_PRIORITY_%s' % name, True) or 0
            depends = ldata.getVar('LAYERDEPENDS_%s' % name, True) or ''

            l = Layer(layer_path, lconf, name, int(priority), pattern, set(depends.split()))
            layers.append(l)

        if layers:
            return layers


def get_layers(data, oedir):
    import bb.parse

    all_layers = set()
    seen_paths = set()
    for pattern in layer_patterns:
        pattern = pattern.format(oedir=oedir)
        for layer_path in glob.glob(pattern):
            layer_path = os.path.realpath(layer_path)
            if layer_path in seen_paths:
                continue
            seen_paths.add(layer_path)

            lconf = os.path.join(layer_path, 'conf', 'layer.conf')
            if not os.path.exists(lconf):
                continue

            layers = Layer.from_layerpath(layer_path, data)
            if layers:
                all_layers |= set(layers)

    return all_layers


def resolve_dependencies(layers_by_name):
    missing_dependencies = defaultdict(set)

    for layer in layers_by_name.values():
        missing_layer_deps = set()
        new_deps = set()

        for depname in layer.depends:
            dep = layers_by_name.get(depname)
            if not dep:
                missing_layer_deps.add(depname)
            else:
                new_deps.add(dep)

        layer.depends = new_deps
        layer.missingdeps = missing_layer_deps
        if missing_layer_deps:
            missing_dependencies[layer.name] = missing_layer_deps

    return missing_dependencies


variable_definition_pattern = "^(# ?)?{0} ?(\??\?)?="
def reconfigure_variables(lines, line_filter=None, valuesdict=None, **values):
    if valuesdict is None:
        valuesdict = {}
    valuesdict.update(values)

    patterns = {}
    for variable in valuesdict:
        patterns[variable] = re.compile(variable_definition_pattern.format(variable))

    def replaced_lines(lines):
        current = None

        for lineno, line in enumerate(lines):
            if line_filter and not line_filter(line):
                continue

            if current:
                if not line.endswith('\\\n'):
                    yield valuesdict[variable]
                    current = None
                continue

            for variable in valuesdict:
                if patterns[variable].match(line):
                    if line.endswith('\\\n'):
                        current = variable
                    else:
                        value = valuesdict[variable]
                        if value is not None:
                            yield value
                    break
            else:
                yield line

    lines = list(replaced_lines(lines))
    return lines


def configure_bblayers(bblconf, layers, opts):
    layer_paths = ['    {0} \\\n'.format(l.path.replace(opts.oedir, '${MELDIR}'))
                   for l in sorted(layers, key=lambda l: l.priority, reverse=True)]
    value = 'BBLAYERS ?= "\\\n{0}"\n'.format(''.join(layer_paths))

    with open(bblconf, 'rU') as f:
        lines = f.readlines()

    lines = reconfigure_variables(lines, line_filter=lambda l: not l.startswith('MELDIR '), BBLAYERS=value)

    with open(bblconf, 'w') as f:
        f.write('MELDIR ?= "{0}"\n'.format(opts.oedir))
        f.writelines(lines)


def configure_local(lconf, opts):
    with open(lconf, 'rU') as f:
        lines = f.readlines()

    value = 'MACHINE ??= "{0}"\n'.format(opts.machine)
    lines = reconfigure_variables(lines, MACHINE=value)

    with open(lconf, 'w') as f:
        f.writelines(lines)


def get_configured_layers(data, opts, all_layers, missing_deps, bblconf):
    data.setVar('MELDIR', opts.oedir)
    data.setVar('OEDIR', opts.oedir)
    data = bb.parse.parse_py.ConfHandler.handle(bblconf, data, include=True)
    base_layer_paths = data.getVar('BBLAYERS', True).split()

    base_layers = set()
    for path in base_layer_paths:
        if not os.path.exists(path):
            raise Exception("Base layer path '{0}' does not exist".format(path))

        for layer in all_layers:
            if layer.path == path:
                base_layers.add(layer)
                break
        else:
            sys.stderr.write("Warning: base layer '{0}' does not match default patterns\n".format(path))
            raise NotImplementedError()

    optional_layers = os.getenv('OPTIONALLAYERS', '').split()
    optional = set()
    configured_layers = set(base_layers)
    for layer in all_layers:
        if os.path.exists(os.path.join(layer.path, 'conf', 'machine',
                                       '{0}.conf'.format(opts.machine))):
            configured_layers.add(layer)
        elif layer.name in optional_layers:
            optional.add(layer)
            configured_layers.add(layer)

    for layer in list(configured_layers):
        if layer.name in missing_deps:
            if layer.name in optional_layers:
                configured_layers.remove(layer)
            else:
                deps = missing_deps[layer.name]
                raise Exception("Missing layer dependencies for '%s': %s" % (layer.name, ', '.join(deps)))

    return configured_layers, optional


def setup_build(cmdline_opts):
    opts = process_arguments(cmdline_opts)

    import bb.parse
    import bb.data

    data = bb.data.init()
    bb.parse.init_parser(data)

    with status('Locating layers and parsing layer.conf files'):
        all_layers = get_layers(data, opts.oedir)

    all_layers = sorted(all_layers, key=lambda l: l.priority)

    for layer in all_layers:
        if not layer.pattern:
            sys.stderr.write("Warning: layer '%s' does not define BBFILE_PATTERN\n" % layer.name)

    with status('Resolving layer dependencies'):
        layers_by_name = dict((l.name, l) for l in all_layers)
        missing_deps = resolve_dependencies(layers_by_name)

    bb.utils.mkdirhier(os.path.join(opts.builddir, 'conf'))


    tmpl_lconf = os.path.join(opts.templatedir, 'local.conf.in')
    new_lconf = os.path.join(opts.builddir, 'conf', 'local.conf')
    if not os.path.exists(new_lconf) or opts.force:
        with status("Copying template conf/local.conf.in to conf/local.conf"):
            shutil.copyfile(tmpl_lconf, new_lconf)
    else:
        print("conf/local.conf already exists, skipping copy")

    if opts.machine:
        if os.path.exists(new_lconf) and not opts.force:
            message = "Reconfiguring existing local.conf for {0}".format(opts.machine)
        else:
            message = "Configuring new local.conf for {0}".format(opts.machine)

        with status(message):
            configure_local(new_lconf, opts)


    tmpl_bblconf = os.path.join(opts.templatedir, 'bblayers.conf.in')
    new_bblconf = os.path.join(opts.builddir, 'conf', 'bblayers.conf')
    if not os.path.exists(new_bblconf) or opts.force:
        with status("Copying template conf/bblayers.conf.in to conf/bblayers.conf"):
            shutil.copyfile(tmpl_bblconf, new_bblconf)
    else:
        print("conf/bblayers.conf already exists, skipping copy")

    if opts.machine:
        with status("Determining layers to include for MACHINE '{0}'".format(opts.machine)):
            try:
                configured_layers, optional = get_configured_layers(data, opts, all_layers, missing_deps, tmpl_bblconf)
            except Exception as exc:
                sys.exit(str(exc))

        for layer in optional:
            print("Layer '{0}' was detected, including in configuration".format(layer.name))

        if os.path.exists(new_bblconf) and not opts.force:
            message = "Reconfiguring existing bblayers.conf for {0}".format(opts.machine)
        else:
            message = "Configuring new bblayers.conf for {0}".format(opts.machine)

        with status(message):
            configure_bblayers(new_bblconf, configured_layers, opts)


if __name__ == '__main__':
    signal.signal(signal.SIGTERM, sigterm_exception)
    try:
        sys.exit(setup_build(sys.argv[1:]) or 0)
    except KeyboardInterrupt:
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        os.kill(os.getpid(), signal.SIGINT)
    except Terminate:
        signal.signal(signal.SIGTERM, signal.SIG_DFL)
        os.kill(os.getpid(), signal.SIGTERM)
